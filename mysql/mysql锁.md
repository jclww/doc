### 锁的种类
- 共享锁（读锁S）：允许事务对一条行数据进行读取；
- 互斥锁（写锁X）：允许事务对一条行数据进行删除或更新；
> 共享锁之间是兼容的，而互斥锁与其他任意锁都不兼容;所以我们可以在数据库中并行读，但是只能串行写，只有这样才能保证不会发生线程竞争，实现线程安全。

### 锁的粒度
无论是共享锁还是互斥锁其实都只是对某一个数据行进行加锁，InnoDB 支持多种粒度的锁，也就是行锁和表锁；为了支持多粒度锁定，InnoDB 存储引擎引入了意向锁（Intention Lock），意向锁就是一种**表级锁**。
- **意向共享锁**（IS）：事务想要在获得表中某些记录的共享锁，需要在表上先加意向共享锁；
- **意向排他锁**（IX）：事务想要在获得表中某些记录的互斥锁，需要在表上先加意向互斥锁；
### 锁类型之间的兼容矩阵

&nbsp; | IS | IX | S | X
---|---|---|---|---
IS | 兼容| 兼容| 兼容 | 不兼容
IX | 兼容| 兼容| 不兼容 | 不兼容
S | 兼容| 不兼容| 兼容 | 不兼容
X | 不兼容| 不兼容| 不兼容 | 不兼容
> 意向锁其实不会阻塞全表扫描之外的任何请求，它们的主要目的是为了表示**是否有人请求锁定表中的某一行数据。**

### 锁的算法
- Record Lock（记录锁）
> 记录锁（Record Lock）是加到索引记录上的锁

例如:`SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;` 可以防止从插入，更新或删除行，其中的值的任何情况`t.c1`都是10。

> Lock 10
- Gap Lock（间隙锁）
> 间隙锁是对索引记录中的一段连续区域的锁

间隙锁是锁定索引记录之间的间隙，或锁定在第一个或最后一个索引记录之前的间隙。例如，`SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;`阻止其他事务将值15插入列`t.c1`，无论列 中是否已存在任何此类值，因为该范围中所有现有值之间的间隙都已锁定。
> Lock [10, 20]
- Next-Key Lock
> Next-Key Lock锁是索引记录上的记录锁和索引记录之前的间隙锁的组合。

InnoDB以这样一种方式执行行级锁定：当它搜索或扫描表索引时，它会在遇到的索引记录上设置共享锁或排它锁。因此，行级锁实际上是索引记录锁。索引记录上的下一键锁也会影响该索引记录之前的“ 间隙 ”。也就是说，下一键锁定是索引记录锁加上索引记录之前的间隙上的间隙锁。  
假设索引包含值10,11,13和20.此索引的可能的下一个键锁定包括以下间隔，其中圆括号表示排除间隔端点，方括号表示包含端点：
```
(negative infinity, 10]
(10, 11]
(11, 13]
(13, 20]
(20, positive infinity)
```

### link
https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html